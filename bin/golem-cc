#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');
const crypto = require('crypto');
const { execSync } = require('child_process');
const colors = require('../lib/colors.js');
const errors = require('../lib/errors.js');
const diagnostics = require('../lib/diagnostics.js');
const integrity = require('../lib/integrity.js');

// ============================================================================
// golem-cc — User Scope Installer
// Run: pnpm dlx golem-cc
// ============================================================================

const HOME = os.homedir();
const GOLEM_HOME = process.env.GOLEM_HOME || path.join(HOME, '.golem');
const CLAUDE_HOME = path.join(HOME, '.claude');
const PKG_ROOT = path.resolve(__dirname, '..');

// Read version from package.json (#10)
const PKG_VERSION = require(path.join(PKG_ROOT, 'package.json')).version;

const { GREEN, YELLOW, RED, CYAN, BOLD, DIM, NC } = colors;

function log(msg) { console.log(colors.log(msg)); }
function warn(msg) { console.log(colors.warn(msg)); }
function heading(msg) { console.log(colors.heading(msg)); }

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true, mode: 0o700 });
}

function fileHash(filepath) {
  if (!fs.existsSync(filepath)) return null;
  return crypto.createHash('sha256').update(fs.readFileSync(filepath)).digest('hex');
}

// Decide what action to take for a file based on hash comparison
// Returns: 'install' | 'unchanged' | 'update' | 'skip' | 'backup-and-update'
function decideAction(newHash, destHash, backupHash) {
  if (!destHash) return 'install';
  if (newHash === destHash) return 'unchanged';
  if (backupHash && backupHash === destHash) return 'update';
  if (backupHash) return 'skip';
  return 'backup-and-update';
}

// Idempotent copy (#11): skip if identical, backup if different, warn if user-modified
// verifyIntegrity: if true and checksums.json exists, verify file before copy
function smartCopy(src, dest, { label = '', verifyIntegrity = false } = {}) {
  // Symlink protection — refuse to overwrite symlinks (path traversal risk)
  if (fs.existsSync(dest) && fs.lstatSync(dest).isSymbolicLink()) {
    warn(`Refusing to overwrite symlink: ${dest.replace(HOME, '~')}`);
    return 'blocked';
  }

  // Integrity verification (if enabled and checksums available)
  if (verifyIntegrity) {
    const relPath = path.relative(PKG_ROOT, src);
    const checksumsPath = path.join(PKG_ROOT, 'checksums.json');
    if (fs.existsSync(checksumsPath)) {
      const checksums = JSON.parse(fs.readFileSync(checksumsPath, 'utf8'));
      const expectedHash = checksums[relPath];
      if (expectedHash && !integrity.verifyChecksum(src, expectedHash)) {
        const err = errors.formatError({
          message: `Integrity check failed: ${relPath}`,
          context: { file: src, expected: expectedHash },
          diagnostics: { ...diagnostics.detectState(GOLEM_HOME), integrityFailure: true },
          suggestion: 'File may be corrupted. Try reinstalling: pnpm dlx golem-cc@latest'
        });
        throw new Error(err);
      }
    }
  }

  const srcHash = fileHash(src);
  const destHash = fileHash(dest);
  const backupPath = dest + '.pre-golem';
  const backupHash = fileHash(backupPath);
  const prettyDest = dest.replace(HOME, '~');
  const action = decideAction(srcHash, destHash, backupHash);

  switch (action) {
    case 'install':
      fs.copyFileSync(src, dest);
      log(`Installed ${prettyDest}`);
      return 'installed';
    case 'unchanged':
      log(`${DIM}Unchanged ${prettyDest}${NC}`);
      return 'unchanged';
    case 'update':
      fs.copyFileSync(src, dest);
      log(`Updated ${prettyDest}`);
      return 'updated';
    case 'skip':
      warn(`${prettyDest} has local modifications — not overwriting`);
      warn(`  New version saved as ${prettyDest}.new — merge manually`);
      fs.copyFileSync(src, dest + '.new');
      return 'skipped';
    case 'backup-and-update':
      fs.copyFileSync(dest, backupPath);
      warn(`Backed up existing ${path.basename(dest)} → ${path.basename(backupPath)}`);
      fs.copyFileSync(src, dest);
      log(`Updated ${prettyDest}`);
      return 'updated';
  }
}

function copyDir(srcDir, destDir, { verifyIntegrity = false } = {}) {
  ensureDir(destDir);
  if (!fs.existsSync(srcDir)) return;
  for (const file of fs.readdirSync(srcDir)) {
    // Path traversal protection
    if (file.includes('..') || file.includes('/') || file.includes('\\')) {
      warn(`Skipped suspicious filename: ${file}`);
      continue;
    }
    const srcFile = path.join(srcDir, file);
    const destFile = path.join(destDir, file);
    const stats = fs.lstatSync(srcFile);
    if (stats.isSymbolicLink()) {
      warn(`Skipped symlink: ${file}`);
      continue;
    }
    if (stats.isFile()) {
      smartCopy(srcFile, destFile, { verifyIntegrity });
    }
  }
}

function cleanCommentKeys(obj) {
  if (Array.isArray(obj)) return obj.map(cleanCommentKeys);
  if (obj && typeof obj === 'object') {
    const clean = {};
    for (const [k, v] of Object.entries(obj)) {
      if (k.startsWith('//')) continue;
      clean[k] = cleanCommentKeys(v);
    }
    return clean;
  }
  return obj;
}

function writeCleanJson(src, dest, { verifyIntegrity = false } = {}) {
  // Symlink protection — refuse to overwrite symlinks (path traversal risk)
  if (fs.existsSync(dest) && fs.lstatSync(dest).isSymbolicLink()) {
    warn(`Refusing to overwrite symlink: ${dest.replace(HOME, '~')}`);
    return 'blocked';
  }

  // Integrity verification (if enabled and checksums available)
  if (verifyIntegrity) {
    const relPath = path.relative(PKG_ROOT, src);
    const checksumsPath = path.join(PKG_ROOT, 'checksums.json');
    if (fs.existsSync(checksumsPath)) {
      const checksums = JSON.parse(fs.readFileSync(checksumsPath, 'utf8'));
      const expectedHash = checksums[relPath];
      if (expectedHash && !integrity.verifyChecksum(src, expectedHash)) {
        const err = errors.formatError({
          message: `Integrity check failed: ${relPath}`,
          context: { file: src, expected: expectedHash },
          diagnostics: { ...diagnostics.detectState(GOLEM_HOME), integrityFailure: true },
          suggestion: 'File may be corrupted. Try reinstalling: pnpm dlx golem-cc@latest'
        });
        throw new Error(err);
      }
    }
  }

  const raw = fs.readFileSync(src, 'utf-8');
  let obj;
  try { obj = JSON.parse(raw); } catch { fs.copyFileSync(src, dest); return; }
  // Resolve ${HOME} and $HOME — Claude Code doesn't shell-expand env in JSON configs
  const clean = JSON.stringify(cleanCommentKeys(obj), null, 2)
    .replace(/\$\{HOME\}/g, HOME)
    .replace(/\$HOME(?![A-Za-z0-9_])/g, HOME);
  const prettyDest = dest.replace(HOME, '~');
  const newHash = crypto.createHash('sha256').update(clean).digest('hex');
  const destHash = fileHash(dest);
  const backupPath = dest + '.pre-golem';
  const backupHash = fileHash(backupPath);
  const action = decideAction(newHash, destHash, backupHash);

  switch (action) {
    case 'install':
      fs.writeFileSync(dest, clean);
      log(`Installed ${prettyDest}`);
      break;
    case 'unchanged':
      log(`${DIM}Unchanged ${prettyDest}${NC}`);
      break;
    case 'update':
      fs.writeFileSync(dest, clean);
      log(`Updated ${prettyDest}`);
      break;
    case 'skip':
      warn(`${prettyDest} has local modifications — not overwriting`);
      warn(`  New version saved as ${prettyDest}.new — merge manually`);
      fs.writeFileSync(dest + '.new', clean);
      break;
    case 'backup-and-update':
      fs.copyFileSync(dest, backupPath);
      warn(`Backed up existing ${path.basename(dest)} → ${path.basename(backupPath)}`);
      fs.writeFileSync(dest, clean);
      log(`Updated ${prettyDest}`);
      break;
  }
}

// ============================================================================
// Exports for testing — functions are available via require() without running install
// ============================================================================

module.exports = { fileHash, decideAction, smartCopy, copyDir, cleanCommentKeys, writeCleanJson, ensureDir };

// ============================================================================
// Banner + Main installation — only runs when executed directly
// ============================================================================

if (require.main === module) {

console.log(`
${BOLD}${CYAN}╔═══════════════════════════════════════════╗
║     Golem v${PKG_VERSION.padEnd(31)}║
╚═══════════════════════════════════════════╝${NC}
`);

try {

// ============================================================================
// 1. Create directory structure
// ============================================================================

heading('Creating directories...');

for (const d of [
  GOLEM_HOME,
  path.join(GOLEM_HOME, 'bin'),
  path.join(GOLEM_HOME, 'lib'),
  path.join(GOLEM_HOME, 'skills', 'frameworks'),
  path.join(GOLEM_HOME, 'skills', 'databases'),
  path.join(GOLEM_HOME, 'hooks'),
  path.join(GOLEM_HOME, 'templates', 'commands'),
  path.join(GOLEM_HOME, 'templates', 'agents'),
  CLAUDE_HOME,
  path.join(CLAUDE_HOME, 'agents'),
]) {
  ensureDir(d);
}

// ============================================================================
// 2. Write version stamp (#10)
// ============================================================================

fs.writeFileSync(path.join(GOLEM_HOME, 'version'), PKG_VERSION);
log(`Version: ${PKG_VERSION}`);

// ============================================================================
// 3. Install user-scope Claude Code config
// ============================================================================

heading('Installing user-scope config...');

// ~/.claude/CLAUDE.md — Golem brain (VERIFY INTEGRITY)
smartCopy(
  path.join(PKG_ROOT, 'user-scope', 'claude-md.md'),
  path.join(CLAUDE_HOME, 'CLAUDE.md'),
  { verifyIntegrity: true }
);

// ~/.claude/settings.json — Global settings, hooks, permissions (VERIFY INTEGRITY)
const settingsSrc = path.join(PKG_ROOT, 'user-scope', 'settings.json');
const settingsDest = path.join(CLAUDE_HOME, 'settings.json');
if (fs.existsSync(settingsSrc)) {
  writeCleanJson(settingsSrc, settingsDest, { verifyIntegrity: true });
  if (fs.existsSync(settingsDest)) fs.chmodSync(settingsDest, 0o600);
}

// ~/.claude/agents/security-scanner.md — Always-on security (VERIFY INTEGRITY)
smartCopy(
  path.join(PKG_ROOT, 'user-scope', 'agents', 'security-scanner.md'),
  path.join(CLAUDE_HOME, 'agents', 'security-scanner.md'),
  { verifyIntegrity: true }
);

// ~/.mcp.json — Global MCP servers
const mcpSrc = path.join(PKG_ROOT, 'user-scope', 'mcp.json');
if (fs.existsSync(mcpSrc)) {
  const dest = path.join(HOME, '.mcp.json');
  if (fs.existsSync(dest)) {
    warn('~/.mcp.json already exists — review user-scope/mcp.json and merge manually');
  } else {
    writeCleanJson(mcpSrc, dest);
    if (fs.existsSync(dest)) fs.chmodSync(dest, 0o600);
  }
}

// ============================================================================
// 4. Install skills
// ============================================================================

heading('Installing skill files...');

copyDir(path.join(PKG_ROOT, 'skills', 'frameworks'), path.join(GOLEM_HOME, 'skills', 'frameworks'));
copyDir(path.join(PKG_ROOT, 'skills', 'databases'), path.join(GOLEM_HOME, 'skills', 'databases'));

// ============================================================================
// 5. Install the golem CLI + hooks + templates
// ============================================================================

heading('Installing golem CLI...');

const golemBin = path.join(PKG_ROOT, 'bin', 'golem');
const golemDest = path.join(GOLEM_HOME, 'bin', 'golem');
smartCopy(golemBin, golemDest, { verifyIntegrity: true });
fs.chmodSync(golemDest, 0o755);

// Copy lib files (colors, cache, errors, etc.) — VERIFY INTEGRITY
const libSrc = path.join(PKG_ROOT, 'lib');
if (fs.existsSync(libSrc)) {
  copyDir(libSrc, path.join(GOLEM_HOME, 'lib'), { verifyIntegrity: true });
}

// Hooks — VERIFY INTEGRITY (security-critical)
const hooksSrc = path.join(PKG_ROOT, 'hooks');
if (fs.existsSync(hooksSrc)) {
  copyDir(hooksSrc, path.join(GOLEM_HOME, 'hooks'), { verifyIntegrity: true });
  for (const f of fs.readdirSync(path.join(GOLEM_HOME, 'hooks'))) {
    fs.chmodSync(path.join(GOLEM_HOME, 'hooks', f), 0o755);
  }
}

// Project-scope templates
heading('Installing templates...');
copyDir(path.join(PKG_ROOT, 'project-scope', 'commands'), path.join(GOLEM_HOME, 'templates', 'commands'));
copyDir(path.join(PKG_ROOT, 'project-scope', 'agents'), path.join(GOLEM_HOME, 'templates', 'agents'));

for (const f of ['settings.json', 'settings.local.json', 'mcp.json']) {
  const src = path.join(PKG_ROOT, 'project-scope', f);
  if (fs.existsSync(src)) {
    smartCopy(src, path.join(GOLEM_HOME, 'templates', f));
  }
}

// ============================================================================
// 6. PATH setup
// ============================================================================

heading('Checking PATH...');

const pathLine = `\n# Golem\nexport PATH="$PATH:$HOME/.golem/bin"\n`;
let pathAdded = false;
let rcFound = false;

for (const rc of ['.zshrc', '.bashrc']) {
  const rcPath = path.join(HOME, rc);
  if (fs.existsSync(rcPath)) {
    rcFound = true;
    const content = fs.readFileSync(rcPath, 'utf-8');
    if (!content.includes('.golem/bin')) {
      fs.appendFileSync(rcPath, pathLine);
      log(`Added ~/.golem/bin to PATH in ${rc}`);
      pathAdded = true;
    } else {
      log(`PATH already configured in ${rc}`);
    }
  }
}

if (!rcFound) {
  warn(`No .zshrc or .bashrc found in ${HOME}`);
  warn(`Add this to your shell config manually:`);
  warn(`  export PATH="$PATH:$HOME/.golem/bin"`);
}

// ============================================================================
// 7. Write install manifest (for clean uninstall)
// ============================================================================

const installedFiles = [
  path.join(CLAUDE_HOME, 'CLAUDE.md'),
  path.join(CLAUDE_HOME, 'settings.json'),
  path.join(CLAUDE_HOME, 'agents', 'security-scanner.md'),
  path.join(HOME, '.mcp.json'),
].filter(f => fs.existsSync(f));
fs.writeFileSync(
  path.join(GOLEM_HOME, 'installed-files.json'),
  JSON.stringify(installedFiles, null, 2)
);

// ============================================================================
// 8. MCP server validation (#12)
// ============================================================================

heading('Validating MCP servers...');

const mcpPackages = ['@upstash/context7-mcp'];
for (const pkg of mcpPackages) {
  try {
    execSync(`npm view ${pkg} version`, { stdio: 'pipe', timeout: 10000 });
    log(`${pkg} — available on npm`);
  } catch {
    warn(`${pkg} — could not verify on npm (may still work)`);
  }
}

// ============================================================================
// Summary
// ============================================================================

console.log(`
${BOLD}${GREEN}═══════════════════════════════════════════${NC}
${BOLD}${GREEN}  User scope installation complete.${NC}
${BOLD}${GREEN}  Version: ${PKG_VERSION}${NC}
${BOLD}${GREEN}═══════════════════════════════════════════${NC}

  ${BOLD}Installed:${NC}
    ~/.claude/CLAUDE.md              ${DIM}← Golem brain${NC}
    ~/.claude/settings.json          ${DIM}← Global hooks, permissions, env vars${NC}
    ~/.claude/agents/security-scanner.md  ${DIM}← Always-on hull integrity${NC}
    ~/.mcp.json                      ${DIM}← Global MCP servers${NC}
    ~/.golem/bin/golem               ${DIM}← The CLI${NC}
    ~/.golem/skills/                 ${DIM}← Framework & database reference${NC}
    ~/.golem/templates/              ${DIM}← Project-scope templates${NC}

  ${BOLD}Next:${NC}
    ${CYAN}cd your-project${NC}
    ${CYAN}golem init${NC}

  ${BOLD}Diagnostics:${NC}
    ${CYAN}golem doctor${NC}                     ${DIM}← Verify everything works${NC}
${pathAdded ? `\n  ${YELLOW}⚠ Restart your terminal or run: source ~/.zshrc${NC}` : ''}
`);

} catch (err) {
  const context = {
    errorCode: err.code || 'unknown',
    message: err.message,
  };

  let suggestion = 'Check the error details below and retry';
  if (err.code === 'EACCES') {
    suggestion = 'Check ownership of ~/.claude/ and ~/.golem/ (run: ls -la ~/)';
  } else if (err.code === 'ENOSPC') {
    suggestion = 'Free up disk space and try again (run: df -h)';
  }

  const diag = diagnostics.detectState(GOLEM_HOME);

  console.error('\n' + errors.formatError({
    message: `Installation failed: ${err.message}`,
    context: context,
    diagnostics: diag,
    suggestion: suggestion,
  }));

  if (!err.code || (err.code !== 'EACCES' && err.code !== 'ENOSPC')) {
    console.error(`${DIM}${err.stack}${NC}`);
  }

  process.exit(1);
}

} // end if (require.main === module)
