#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');
const { execSync, spawnSync } = require('child_process');

// ============================================================================
// golem — CLI dispatcher
// ============================================================================

const HOME = os.homedir();
const GOLEM_HOME = process.env.GOLEM_HOME || path.join(HOME, '.golem');
const VERSION_FILE = path.join(GOLEM_HOME, 'version');

const GREEN = '\x1b[32m';
const YELLOW = '\x1b[33m';
const RED = '\x1b[31m';
const CYAN = '\x1b[36m';
const BOLD = '\x1b[1m';
const DIM = '\x1b[2m';
const NC = '\x1b[0m';

function getVersion() {
  try { return fs.readFileSync(VERSION_FILE, 'utf-8').trim(); } catch { return 'unknown'; }
}

// ============================================================================
// Command definitions
// ============================================================================

const WORKFLOW_COMMANDS = {
  discuss: '1. Start a discussion about the project',
  spec:    '2. Write or refine a specification',
  plan:    '3. Create an implementation plan',
  build:   '4. Execute the build loop (Red/Green/Refactor/Secure)',
  release: '5. Cut a release',
  resume:  '   Resume an interrupted build',
};

const INTELLIGENCE_COMMANDS = {
  status: 'Show current golem state and progress',
  sweep: 'Run a security sweep',
  recon: 'Reconnaissance — analyze codebase',
  diff: 'Show git diff summary',
  log: 'Show golem build/session logs',
};

const MAINTENANCE_COMMANDS = {
  version: 'Show golem version',
  update: 'Update golem to latest version',
  doctor: 'Run diagnostics',
  init: 'Initialize golem in a project',
  reset: 'Reset golem state for this project',
  eject: 'Remove golem from this project (keeps code)',
  uninstall: 'Remove golem from this machine entirely',
};

// ============================================================================
// Helpers
// ============================================================================

function hasCommand(cmd) {
  if (!/^[a-zA-Z0-9_-]+$/.test(cmd)) return false;
  try {
    const result = spawnSync('which', [cmd], { stdio: 'pipe' });
    return result.status === 0;
  } catch { return false; }
}

function claudeSlashCommand(name, args) {
  if (!hasCommand('claude')) {
    console.error(`${RED}Error: claude CLI not found. Install it first: https://docs.anthropic.com/en/docs/claude-code${NC}`);
    process.exit(1);
  }
  const slashCmd = `/golem-${name}` + (args ? ` ${args}` : '');
  const result = spawnSync('claude', ['-p', slashCmd], {
    stdio: 'inherit',
    cwd: process.cwd(),
  });
  process.exit(result.status ?? 1);
}

function detectDatabases() {
  const dbs = [];
  const cwd = process.cwd();

  // Check package.json dependencies
  try {
    const pkg = JSON.parse(fs.readFileSync(path.join(cwd, 'package.json'), 'utf-8'));
    const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };
    if (allDeps.pg || allDeps['@prisma/client'] || allDeps.knex) dbs.push('postgres');
    if (allDeps.oracledb) dbs.push('oracle');
    if (allDeps.mssql || allDeps.tedious) dbs.push('mssql');
    if (allDeps.odbc || allDeps['idb-pconnector']) dbs.push('ibmi');
  } catch {}

  // Check .env.example for connection strings
  try {
    const envEx = fs.readFileSync(path.join(cwd, '.env.example'), 'utf-8').toLowerCase();
    if (envEx.includes('database_url') || envEx.includes('postgres') || envEx.includes('pg_')) dbs.push('postgres');
    if (envEx.includes('oracle') || envEx.includes('ora_')) dbs.push('oracle');
    if (envEx.includes('mssql') || envEx.includes('sqlserver') || envEx.includes('sa_password')) dbs.push('mssql');
    if (envEx.includes('ibmi') || envEx.includes('as400') || envEx.includes('iseries')) dbs.push('ibmi');
  } catch {}

  return [...new Set(dbs)];
}

function printHelp() {
  console.log(`
${BOLD}${CYAN}Super Golem v${getVersion()}${NC}
${DIM}"Let's build something."${NC}

${BOLD}Usage:${NC} golem <command> [arguments]

${BOLD}Workflow:${NC} ${DIM}(run in order)${NC}`);
  for (const [cmd, desc] of Object.entries(WORKFLOW_COMMANDS)) {
    console.log(`  ${GREEN}${cmd.padEnd(12)}${NC} ${desc}`);
  }
  console.log(`\n${BOLD}Intelligence:${NC}`);
  for (const [cmd, desc] of Object.entries(INTELLIGENCE_COMMANDS)) {
    console.log(`  ${CYAN}${cmd.padEnd(12)}${NC} ${desc}`);
  }
  console.log(`\n${BOLD}Maintenance:${NC}`);
  for (const [cmd, desc] of Object.entries(MAINTENANCE_COMMANDS)) {
    console.log(`  ${YELLOW}${cmd.padEnd(12)}${NC} ${desc}`);
  }
  console.log();
}

// ============================================================================
// Command implementations
// ============================================================================

function cmdVersion() {
  console.log(`golem v${getVersion()}`);
}

function cmdDoctor() {
  console.log(`\n${BOLD}${CYAN}Golem Doctor${NC}\n`);
  const checks = [];

  // Node version
  const nodeVer = process.version;
  const major = parseInt(nodeVer.slice(1));
  checks.push({ name: 'Node.js >= 18', ok: major >= 18, detail: nodeVer });

  // claude CLI
  checks.push({ name: 'claude CLI', ok: hasCommand('claude'), detail: hasCommand('claude') ? 'found' : 'not found' });

  // git
  checks.push({ name: 'git', ok: hasCommand('git'), detail: hasCommand('git') ? 'found' : 'not found' });

  // python3
  checks.push({ name: 'python3', ok: hasCommand('python3'), detail: hasCommand('python3') ? 'found' : 'not found (optional)' });

  // jq
  checks.push({ name: 'jq', ok: hasCommand('jq'), detail: hasCommand('jq') ? 'found' : 'not found (REQUIRED for security hooks)' });

  // semgrep
  const hasSemgrep = hasCommand('semgrep');
  checks.push({ name: 'semgrep', ok: hasSemgrep, detail: hasSemgrep ? 'found' : 'not found (optional)', optional: true });

  // Golem home
  const homeExists = fs.existsSync(GOLEM_HOME);
  checks.push({ name: 'GOLEM_HOME', ok: homeExists, detail: homeExists ? GOLEM_HOME : 'missing' });

  // Version file
  const versionExists = fs.existsSync(VERSION_FILE);
  checks.push({ name: 'Version stamp', ok: versionExists, detail: versionExists ? getVersion() : 'missing' });

  // Claude home
  const claudeHome = path.join(HOME, '.claude');
  const claudeMd = path.join(claudeHome, 'CLAUDE.md');
  checks.push({ name: '~/.claude/CLAUDE.md', ok: fs.existsSync(claudeMd), detail: fs.existsSync(claudeMd) ? 'found' : 'missing' });

  // Templates
  const templatesDir = path.join(GOLEM_HOME, 'templates');
  checks.push({ name: 'Templates', ok: fs.existsSync(templatesDir), detail: fs.existsSync(templatesDir) ? 'installed' : 'missing' });

  // Print results
  let allOk = true;
  for (const c of checks) {
    const icon = c.ok ? `${GREEN}OK${NC}` : (c.optional ? `${YELLOW}--${NC}` : `${RED}FAIL${NC}`);
    console.log(`  ${icon}  ${c.name.padEnd(22)} ${DIM}${c.detail}${NC}`);
    if (!c.ok && !c.optional) allOk = false;
  }

  console.log();
  if (allOk) {
    console.log(`  ${GREEN}All required checks passed.${NC}\n`);
  } else {
    console.log(`  ${RED}Some required checks failed. Run 'pnpm dlx golem-cc' to reinstall.${NC}\n`);
    process.exit(1);
  }
}

function cmdInit(args = []) {
  const cwd = process.cwd();
  const blocked = ['/', '/usr', '/bin', '/sbin', '/etc', '/var', '/opt', '/tmp',
                   '/Library', '/System', HOME];
  if (blocked.includes(cwd)) {
    console.error(`${RED}Cannot initialize golem in ${cwd}${NC}`);
    console.error(`${YELLOW}Navigate to a project directory first.${NC}`);
    process.exit(1);
  }

  // Parse flags for explicit stack/db overrides
  const flags = new Set(args.filter(a => a.startsWith('--')).map(a => a.slice(2).toLowerCase()));

  console.log(`\n${BOLD}${CYAN}Initializing golem in ${cwd}${NC}\n`);

  // Create .claude and .golem dirs
  for (const dir of ['.claude/commands', '.claude/agents', '.golem/logs', '.golem/plans']) {
    fs.mkdirSync(path.join(process.cwd(), dir), { recursive: true });
    console.log(`  ${GREEN}Created${NC} ${dir}/`);
  }

  // Copy templates
  const templatesDir = path.join(GOLEM_HOME, 'templates');
  if (!fs.existsSync(templatesDir)) {
    console.error(`${RED}Templates not found at ${templatesDir}. Run 'pnpm dlx golem-cc' first.${NC}`);
    process.exit(1);
  }

  // Commands
  const commandsSrc = path.join(templatesDir, 'commands');
  if (fs.existsSync(commandsSrc)) {
    for (const file of fs.readdirSync(commandsSrc)) {
      const dest = path.join(process.cwd(), '.claude', 'commands', file);
      if (!fs.existsSync(dest)) {
        fs.copyFileSync(path.join(commandsSrc, file), dest);
        console.log(`  ${GREEN}Installed${NC} .claude/commands/${file}`);
      } else {
        console.log(`  ${DIM}Exists${NC}    .claude/commands/${file}`);
      }
    }
  }

  // Agents
  const agentsSrc = path.join(templatesDir, 'agents');
  if (fs.existsSync(agentsSrc)) {
    for (const file of fs.readdirSync(agentsSrc)) {
      const dest = path.join(process.cwd(), '.claude', 'agents', file);
      if (!fs.existsSync(dest)) {
        fs.copyFileSync(path.join(agentsSrc, file), dest);
        console.log(`  ${GREEN}Installed${NC} .claude/agents/${file}`);
      } else {
        console.log(`  ${DIM}Exists${NC}    .claude/agents/${file}`);
      }
    }
  }

  // settings.json
  const settingsSrc = path.join(templatesDir, 'settings.json');
  const settingsDest = path.join(process.cwd(), '.claude', 'settings.json');
  if (fs.existsSync(settingsSrc) && !fs.existsSync(settingsDest)) {
    fs.copyFileSync(settingsSrc, settingsDest);
    console.log(`  ${GREEN}Installed${NC} .claude/settings.json`);
  }

  // mcp.json
  const mcpSrc = path.join(templatesDir, 'mcp.json');
  const mcpDest = path.join(process.cwd(), '.mcp.json');
  if (fs.existsSync(mcpSrc) && !fs.existsSync(mcpDest)) {
    fs.copyFileSync(mcpSrc, mcpDest);
    console.log(`  ${GREEN}Installed${NC} .mcp.json`);
  }

  // Initialize state
  const stateDest = path.join(process.cwd(), '.golem', 'state.json');
  if (!fs.existsSync(stateDest)) {
    fs.writeFileSync(stateDest, JSON.stringify({
      phase: 'initialized',
      tasks_completed: 0,
      tasks_total: 0,
      created: new Date().toISOString(),
    }, null, 2));
    console.log(`  ${GREEN}Created${NC}   .golem/state.json`);
  }

  // CLAUDE.md
  const claudeMdDest = path.join(process.cwd(), 'CLAUDE.md');
  if (!fs.existsSync(claudeMdDest)) {
    // Auto-detect project type (flags override auto-detection)
    let projectType = 'project';
    if (flags.has('nuxt')) projectType = 'Nuxt';
    else if (flags.has('next')) projectType = 'Next.js';
    else if (flags.has('php')) projectType = 'PHP';
    else if (fs.existsSync(path.join(process.cwd(), 'nuxt.config.ts'))) projectType = 'Nuxt';
    else if (fs.existsSync(path.join(process.cwd(), 'next.config.js')) || fs.existsSync(path.join(process.cwd(), 'next.config.ts'))) projectType = 'Next.js';
    else if (fs.existsSync(path.join(process.cwd(), 'composer.json'))) projectType = 'PHP';
    else if (fs.existsSync(path.join(process.cwd(), 'package.json'))) projectType = 'Node.js';

    // Detect databases (flags override/extend auto-detection)
    const detectedDBs = detectDatabases();
    if (flags.has('pg') || flags.has('postgres')) detectedDBs.push('postgres');
    if (flags.has('oracle')) detectedDBs.push('oracle');
    if (flags.has('mssql')) detectedDBs.push('mssql');
    if (flags.has('ibmi')) detectedDBs.push('ibmi');
    // Deduplicate after flag additions
    const uniqueDBs = [...new Set(detectedDBs)];

    // Build skill references
    const skillRefs = [];
    if (projectType === 'Nuxt') skillRefs.push('~/.golem/skills/frameworks/nuxt.md');
    if (projectType === 'Next.js') skillRefs.push('~/.golem/skills/frameworks/next.md');
    if (projectType === 'PHP') skillRefs.push('~/.golem/skills/frameworks/php.md');
    if (uniqueDBs.includes('postgres')) skillRefs.push('~/.golem/skills/databases/postgres.md');
    if (uniqueDBs.includes('oracle')) skillRefs.push('~/.golem/skills/databases/oracle.md');
    if (uniqueDBs.includes('mssql')) skillRefs.push('~/.golem/skills/databases/mssql.md');
    if (uniqueDBs.includes('ibmi')) skillRefs.push('~/.golem/skills/databases/ibmi.md');

    let claudeMd = `# ${path.basename(process.cwd())}

## Project Type
${projectType}

## Conventions
- Follow existing code style
- Write tests for new features
- Use conventional commits

## Environment
- See .env.example for required variables
`;

    if (skillRefs.length > 0) {
      claudeMd += `
## Stack Skills
Read these references before working on this project:
${skillRefs.map(s => `- ${s}`).join('\n')}
`;
    }

    claudeMd += `
## Golem Workflow
Available commands: discuss, spec, plan, build, release, sweep, recon, status
Run \`golem help\` for details.
`;

    fs.writeFileSync(claudeMdDest, claudeMd);
    const detectionSummary = uniqueDBs.length > 0 ? `, DBs: ${uniqueDBs.join(', ')}` : '';
    console.log(`  ${GREEN}Created${NC}   CLAUDE.md (detected: ${projectType}${detectionSummary})`);
    if (skillRefs.length > 0) {
      console.log(`  ${GREEN}Linked${NC}    ${skillRefs.length} skill reference(s)`);
    }
  }

  // .env.example
  const envExDest = path.join(process.cwd(), '.env.example');
  if (!fs.existsSync(envExDest)) {
    fs.writeFileSync(envExDest, '# Add your environment variables here\n');
    console.log(`  ${GREEN}Created${NC}   .env.example`);
  }

  // Ensure .gitignore has .env
  const gitignorePath = path.join(process.cwd(), '.gitignore');
  if (fs.existsSync(gitignorePath)) {
    const content = fs.readFileSync(gitignorePath, 'utf-8');
    const additions = [];
    if (!content.includes('.env')) additions.push('.env');
    if (!content.includes('.golem/')) additions.push('.golem/');
    if (additions.length > 0) {
      fs.appendFileSync(gitignorePath, '\n' + additions.join('\n') + '\n');
      console.log(`  ${GREEN}Updated${NC}   .gitignore (added: ${additions.join(', ')})`);
    }
  }

  console.log(`\n  ${BOLD}${GREEN}Project initialized.${NC} Run ${CYAN}claude${NC} to start.\n`);
}

function cmdStatus() {
  const stateFile = path.join(process.cwd(), '.golem', 'state.json');
  if (!fs.existsSync(stateFile)) {
    console.log(`${YELLOW}No golem state found. Run 'golem init' first.${NC}`);
    process.exit(1);
  }
  let state;
  try {
    state = JSON.parse(fs.readFileSync(stateFile, 'utf-8'));
  } catch {
    console.error(`${RED}Error: .golem/state.json is corrupted.${NC}`);
    console.error(`${YELLOW}Run 'golem reset' to reinitialize state.${NC}`);
    process.exit(1);
  }
  console.log(`\n${BOLD}Golem Status${NC}`);
  console.log(`  Phase:     ${state.phase || 'unknown'}`);
  console.log(`  Tasks:     ${state.tasks_completed || 0}/${state.tasks_total || 0}`);
  console.log(`  Created:   ${state.created || 'unknown'}`);

  // Show git info
  try {
    const branch = execSync('git branch --show-current', { stdio: 'pipe', cwd: process.cwd() }).toString().trim();
    const status = execSync('git status --short', { stdio: 'pipe', cwd: process.cwd() }).toString().trim();
    console.log(`  Branch:    ${branch}`);
    console.log(`  Git:       ${status ? status.split('\n').length + ' changed files' : 'clean'}`);
  } catch { /* not a git repo */ }
  console.log();
}

function cmdReset() {
  const golemDir = path.join(process.cwd(), '.golem');
  if (!fs.existsSync(golemDir)) {
    console.log(`${YELLOW}No .golem directory found.${NC}`);
    return;
  }
  const stateFile = path.join(golemDir, 'state.json');
  if (fs.existsSync(stateFile)) {
    fs.writeFileSync(stateFile, JSON.stringify({
      phase: 'initialized',
      tasks_completed: 0,
      tasks_total: 0,
      created: new Date().toISOString(),
    }, null, 2));
  }
  // Clear logs
  const logsDir = path.join(golemDir, 'logs');
  if (fs.existsSync(logsDir)) {
    fs.rmSync(logsDir, { recursive: true });
    fs.mkdirSync(logsDir, { recursive: true });
  }
  console.log(`${GREEN}Golem state reset.${NC}`);
}

function cmdEject(args = []) {
  const golemDir = path.join(process.cwd(), '.golem');
  if (!fs.existsSync(golemDir)) {
    console.log(`${YELLOW}No .golem directory found.${NC}`);
    return;
  }

  if (!args.includes('--confirm') && !args.includes('-y')) {
    console.log(`${YELLOW}This will permanently delete:${NC}`);
    console.log(`  ${golemDir}/  (all state, logs, plans, specs)`);
    console.log(`\n${BOLD}Run with --confirm to proceed:${NC} golem eject --confirm`);
    return;
  }

  fs.rmSync(golemDir, { recursive: true });
  console.log(`${GREEN}Removed${NC} .golem/`);
  console.log(`${DIM}.claude/ left intact (contains your commands and settings).${NC}`);
  console.log(`${GREEN}Golem ejected. Your code is untouched.${NC}`);
}

function cmdUpdate() {
  console.log(`${CYAN}Updating golem...${NC}`);
  const result = spawnSync('pnpm', ['dlx', 'golem-cc@latest'], {
    stdio: 'inherit',
    cwd: HOME,
  });
  process.exit(result.status ?? 1);
}

function cmdUninstall(args = []) {
  if (!args.includes('--confirm') && !args.includes('-y')) {
    console.log(`\n${BOLD}${YELLOW}Golem Uninstall${NC}\n`);
    console.log(`This will:`);
    console.log(`  1. Restore any .pre-golem backup files in ~/.claude/`);
    console.log(`  2. Remove ~/.golem/ entirely`);
    console.log(`  3. Remove the PATH entry from shell RC files`);
    console.log(`\n${BOLD}Run with --confirm to proceed:${NC} golem uninstall --confirm`);
    return;
  }

  const CLAUDE_HOME = path.join(HOME, '.claude');
  const GOLEM_HOME_DIR = path.join(HOME, '.golem');

  // 1. Restore .pre-golem backups in ~/.claude/
  if (fs.existsSync(CLAUDE_HOME)) {
    const restoreBackups = (dir) => {
      if (!fs.existsSync(dir)) return;
      for (const file of fs.readdirSync(dir)) {
        const full = path.join(dir, file);
        const stat = fs.lstatSync(full);
        if (stat.isDirectory()) { restoreBackups(full); continue; }
        if (file.endsWith('.pre-golem')) {
          const original = full.replace(/\.pre-golem$/, '');
          fs.renameSync(full, original);
          console.log(`  ${GREEN}Restored${NC} ${original.replace(HOME, '~')}`);
        }
      }
    };
    restoreBackups(CLAUDE_HOME);
    // Clean up .new files left by smartCopy
    const cleanNewFiles = (dir) => {
      if (!fs.existsSync(dir)) return;
      for (const file of fs.readdirSync(dir)) {
        const full = path.join(dir, file);
        const stat = fs.lstatSync(full);
        if (stat.isDirectory()) { cleanNewFiles(full); continue; }
        if (file.endsWith('.new')) {
          fs.unlinkSync(full);
          console.log(`  ${DIM}Removed${NC}   ${full.replace(HOME, '~')}`);
        }
      }
    };
    cleanNewFiles(CLAUDE_HOME);
  }

  // 2. Remove ~/.golem/
  if (fs.existsSync(GOLEM_HOME_DIR)) {
    fs.rmSync(GOLEM_HOME_DIR, { recursive: true });
    console.log(`  ${GREEN}Removed${NC}   ~/.golem/`);
  }

  // 3. Remove PATH entry from shell RC files
  for (const rc of ['.zshrc', '.bashrc']) {
    const rcPath = path.join(HOME, rc);
    if (!fs.existsSync(rcPath)) continue;
    const content = fs.readFileSync(rcPath, 'utf-8');
    if (content.includes('.golem/bin')) {
      const cleaned = content
        .replace(/\n# Super Golem\nexport PATH="\$PATH:\$HOME\/\.golem\/bin"\n/g, '')
        .replace(/\n# Super Golem\nexport PATH="\$HOME\/\.golem\/bin:\$PATH"\n/g, '');
      if (cleaned !== content) {
        fs.writeFileSync(rcPath, cleaned);
        console.log(`  ${GREEN}Cleaned${NC}   ~/${rc} (removed PATH entry)`);
      }
    }
  }

  console.log(`\n${GREEN}Golem uninstalled.${NC}`);
  console.log(`${DIM}Your projects are untouched. Run 'golem eject' in each project to remove .golem/ dirs.${NC}`);
}

function cmdLog(args = []) {
  const logsDir = path.join(process.cwd(), '.golem', 'logs');
  if (!fs.existsSync(logsDir)) {
    console.log(`${YELLOW}No logs found. Run 'golem init' first.${NC}`);
    return;
  }
  const files = fs.readdirSync(logsDir).sort().reverse();
  if (files.length === 0) {
    console.log(`${DIM}No log entries yet.${NC}`);
    return;
  }
  // Show N most recent logs (default 1)
  const count = Math.max(1, parseInt(args[0]) || 1);
  const toShow = files.slice(0, count);
  for (const file of toShow) {
    console.log(`${BOLD}${file}${NC}\n`);
    console.log(fs.readFileSync(path.join(logsDir, file), 'utf-8'));
    if (toShow.length > 1) console.log(`${DIM}${'─'.repeat(40)}${NC}\n`);
  }
}

function cmdDiff() {
  if (!hasCommand('git')) {
    console.error(`${RED}git not found.${NC}`);
    process.exit(1);
  }
  const result = spawnSync('git', ['diff', '--stat'], { stdio: 'inherit', cwd: process.cwd() });
  process.exit(result.status ?? 1);
}

// ============================================================================
// Exports for testing — functions are available via require() without running dispatch
// ============================================================================

module.exports = { hasCommand, detectDatabases, cmdInit, cmdStatus, cmdReset, cmdEject, cmdUninstall, cmdLog };

// ============================================================================
// Dispatch — only runs when executed directly
// ============================================================================

if (require.main === module) {

const [,, command, ...args] = process.argv;
const argsStr = args.join(' ');

if (!command || command === '--help' || command === '-h') {
  printHelp();
  process.exit(0);
}

if (command === 'help') {
  if (args[0]) {
    // golem help <command> — show detailed help from command file
    const cmdFile = path.join(process.cwd(), '.claude', 'commands', `golem-${args[0]}.md`);
    if (fs.existsSync(cmdFile)) {
      const content = fs.readFileSync(cmdFile, 'utf-8');
      const descMatch = content.match(/description:\s*(.+)/);
      const toolsMatch = content.match(/allowed-tools:\s*(.+)/);
      console.log(`\n${BOLD}golem ${args[0]}${NC}`);
      if (descMatch) console.log(`  ${descMatch[1]}`);
      if (toolsMatch) console.log(`  ${DIM}Tools: ${toolsMatch[1]}${NC}`);
      console.log(`\n  ${DIM}Full reference: ${cmdFile}${NC}\n`);
    } else {
      // Check if it's a known command
      const allCmds = { ...WORKFLOW_COMMANDS, ...INTELLIGENCE_COMMANDS, ...MAINTENANCE_COMMANDS };
      if (args[0] in allCmds) {
        console.log(`\n${BOLD}golem ${args[0]}${NC}: ${allCmds[args[0]]}\n`);
      } else {
        console.log(`${YELLOW}No help available for '${args[0]}'${NC}`);
      }
    }
  } else {
    printHelp();
  }
  process.exit(0);
}

// Workflow commands → shell out to claude with slash command
if (command in WORKFLOW_COMMANDS) {
  if (command === 'discuss' && !argsStr.trim()) {
    console.error(`${RED}Usage: golem discuss "your topic here"${NC}`);
    process.exit(1);
  }
  claudeSlashCommand(command, argsStr);
}

// Intelligence commands
switch (command) {
  case 'status': cmdStatus(); break;
  case 'sweep': claudeSlashCommand('sweep', argsStr); break;
  case 'recon': claudeSlashCommand('recon', argsStr); break;
  case 'diff': cmdDiff(); break;
  case 'log': cmdLog(args); break;

  // Maintenance commands
  case 'version': case '--version': case '-v': cmdVersion(); break;
  case 'doctor': cmdDoctor(); break;
  case 'init': cmdInit(args); break;
  case 'reset': cmdReset(); break;
  case 'eject': cmdEject(args); break;
  case 'uninstall': cmdUninstall(args); break;
  case 'update': cmdUpdate(); break;

  default:
    console.error(`${RED}Unknown command: ${command}${NC}\n`);
    printHelp();
    process.exit(1);
}

} // end if (require.main === module)
