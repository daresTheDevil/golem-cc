#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');
const { execSync, spawnSync } = require('child_process');

// ============================================================================
// golem — CLI dispatcher
// ============================================================================

const HOME = os.homedir();
const GOLEM_HOME = process.env.GOLEM_HOME || path.join(HOME, '.golem');
const VERSION_FILE = path.join(GOLEM_HOME, 'version');

// Minimal fallback implementations for dev/test when lib not installed
function createFallbackFormatError() {
  return ({ message, context = {}, suggestion = '' }) => {
    let msg = `Error: ${message}`;
    if (Object.keys(context).length > 0) {
      msg += '\nContext:\n' + Object.entries(context).map(([k, v]) => `  ${k}: ${JSON.stringify(v)}`).join('\n');
    }
    if (suggestion) msg += `\nSuggested fix:\n  ${suggestion}`;
    return msg;
  };
}

// Load colors, cache, and errors from installed lib or fallback to inline (for development/testing)
let colors, cache, errors, diagnostics;
try {
  colors = require(path.join(GOLEM_HOME, 'lib', 'colors.js'));
  cache = require(path.join(GOLEM_HOME, 'lib', 'cache.js'));
  errors = require(path.join(GOLEM_HOME, 'lib', 'errors.js'));
  diagnostics = require(path.join(GOLEM_HOME, 'lib', 'diagnostics.js'));
} catch {
  // Fallback: inline implementations for dev/test when lib not installed
  const DISABLED = process.env.NO_COLOR !== undefined;
  colors = {
    GREEN: DISABLED ? '' : '\x1b[32m',
    YELLOW: DISABLED ? '' : '\x1b[33m',
    RED: DISABLED ? '' : '\x1b[31m',
    CYAN: DISABLED ? '' : '\x1b[36m',
    BOLD: DISABLED ? '' : '\x1b[1m',
    DIM: DISABLED ? '' : '\x1b[2m',
    NC: DISABLED ? '' : '\x1b[0m',
  };
  cache = {
    get: () => undefined,
    set: () => {},
    clear: () => {},
    clearAll: () => {},
    memoize: (fn) => fn, // No-op memoize
  };
  errors = {
    formatError: createFallbackFormatError(),
  };
  diagnostics = {
    detectState: () => ({ golemHomeExists: false }),
    suggestFix: () => 'Run: pnpm dlx golem-cc',
  };
}

const { GREEN, YELLOW, RED, CYAN, BOLD, DIM, NC } = colors;

function getVersion() {
  try { return fs.readFileSync(VERSION_FILE, 'utf-8').trim(); } catch { return 'unknown'; }
}

// ============================================================================
// Command definitions
// ============================================================================

const WORKFLOW_COMMANDS = {
  discuss: '1. Start a discussion about the project',
  spec:    '2. Write or refine a specification',
  plan:    '3. Create an implementation plan',
  build:   '4. Execute the build loop (Red/Green/Refactor/Secure)',
  release: '5. Cut a release',
  resume:  '   Resume an interrupted build',
};

const INTELLIGENCE_COMMANDS = {
  status: 'Show current golem state and progress',
  sweep: 'Run a security sweep',
  recon: 'Reconnaissance — analyze codebase',
  diff: 'Show git diff summary',
  log: 'Show golem build/session logs',
};

const MAINTENANCE_COMMANDS = {
  version: 'Show golem version',
  update: 'Update golem to latest version',
  doctor: 'Run diagnostics',
  init: 'Initialize golem in a project',
  reset: 'Reset golem state for this project',
  eject: 'Remove golem from this project (keeps code)',
  uninstall: 'Remove golem from this machine entirely',
};

// ============================================================================
// Helpers
// ============================================================================

function sanitizeArgs(str) {
  if (!str) return '';
  // Strip newlines, null bytes, and control characters (keep tab/space)
  return str.replace(/[\x00-\x08\x0b\x0c\x0e-\x1f]/g, '').replace(/[\n\r]+/g, ' ').trim();
}

// Cached version of hasCommand to avoid redundant subprocess spawns
const hasCommand = cache.memoize(function hasCommand(cmd) {
  if (!/^[a-zA-Z0-9_-]+$/.test(cmd)) return false;
  try {
    const result = spawnSync('which', [cmd], { stdio: 'pipe' });
    return result.status === 0;
  } catch { return false; }
});

function claudeSlashCommand(name, args) {
  if (!hasCommand('claude')) {
    const diag = diagnostics.detectState(GOLEM_HOME);
    console.error(errors.formatError({
      message: 'claude CLI not found',
      context: {
        command: name,
        PATH: process.env.PATH ? 'configured' : 'empty',
      },
      diagnostics: diag,
      suggestion: 'Install claude CLI: https://docs.anthropic.com/en/docs/claude-code',
    }));
    process.exit(1);
  }
  const slashCmd = `/golem-${name}` + (args ? ` ${args}` : '');
  const result = spawnSync('claude', ['-p', slashCmd], {
    stdio: 'inherit',
    cwd: process.cwd(),
  });
  process.exit(result.status ?? 1);
}

function detectDatabases() {
  const dbs = [];
  const cwd = process.cwd();

  // Check package.json dependencies
  try {
    const pkg = JSON.parse(fs.readFileSync(path.join(cwd, 'package.json'), 'utf-8'));
    const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };
    if (allDeps.pg || allDeps['@prisma/client'] || allDeps.knex) dbs.push('postgres');
    if (allDeps.oracledb) dbs.push('oracle');
    if (allDeps.mssql || allDeps.tedious) dbs.push('mssql');
    if (allDeps['idb-pconnector'] || allDeps['idb-connector']) dbs.push('ibmi');
  } catch {}

  // Check .env.example for connection strings
  try {
    const envEx = fs.readFileSync(path.join(cwd, '.env.example'), 'utf-8').toLowerCase();
    if (envEx.includes('database_url') || envEx.includes('postgres') || envEx.includes('pg_')) dbs.push('postgres');
    if (envEx.includes('oracle') || envEx.includes('ora_')) dbs.push('oracle');
    if (envEx.includes('mssql') || envEx.includes('sqlserver') || envEx.includes('sa_password')) dbs.push('mssql');
    if (envEx.includes('ibmi') || envEx.includes('as400') || envEx.includes('iseries')) dbs.push('ibmi');
  } catch {}

  return [...new Set(dbs)];
}

function detectProjectType(cwd, flags) {
  if (flags.has('nuxt')) return 'Nuxt';
  if (flags.has('next')) return 'Next.js';
  if (flags.has('php')) return 'PHP';
  if (fs.existsSync(path.join(cwd, 'nuxt.config.ts')) || fs.existsSync(path.join(cwd, 'nuxt.config.js')) || fs.existsSync(path.join(cwd, 'nuxt.config.mjs'))) return 'Nuxt';
  if (fs.existsSync(path.join(cwd, 'next.config.js')) || fs.existsSync(path.join(cwd, 'next.config.ts')) || fs.existsSync(path.join(cwd, 'next.config.mjs'))) return 'Next.js';
  if (fs.existsSync(path.join(cwd, 'composer.json'))) return 'PHP';
  if (fs.existsSync(path.join(cwd, 'package.json'))) return 'Node.js';
  return 'project';
}

function updateGitignore(cwd) {
  const gitignorePath = path.join(cwd, '.gitignore');
  if (!fs.existsSync(gitignorePath)) return;
  const content = fs.readFileSync(gitignorePath, 'utf-8');
  const lines = content.split('\n').map(l => l.trim());
  const additions = [];
  if (!lines.includes('.env')) additions.push('.env');
  if (!lines.includes('.golem/')) additions.push('.golem/');
  if (additions.length > 0) {
    fs.appendFileSync(gitignorePath, '\n' + additions.join('\n') + '\n');
    console.log(`  ${GREEN}Updated${NC}   .gitignore (added: ${additions.join(', ')})`);
  }
}

function printHelp() {
  console.log(`
${BOLD}${CYAN}Super Golem v${getVersion()}${NC}
${DIM}"Let's build something."${NC}

${BOLD}Usage:${NC} golem <command> [arguments]

${BOLD}Workflow:${NC} ${DIM}(run in order)${NC}`);
  for (const [cmd, desc] of Object.entries(WORKFLOW_COMMANDS)) {
    console.log(`  ${GREEN}${cmd.padEnd(12)}${NC} ${desc}`);
  }
  console.log(`\n${BOLD}Intelligence:${NC}`);
  for (const [cmd, desc] of Object.entries(INTELLIGENCE_COMMANDS)) {
    console.log(`  ${CYAN}${cmd.padEnd(12)}${NC} ${desc}`);
  }
  console.log(`\n${BOLD}Maintenance:${NC}`);
  for (const [cmd, desc] of Object.entries(MAINTENANCE_COMMANDS)) {
    console.log(`  ${YELLOW}${cmd.padEnd(12)}${NC} ${desc}`);
  }
  console.log();
}

// ============================================================================
// Command implementations
// ============================================================================

function cmdVersion() {
  console.log(`golem v${getVersion()}`);
}

function cmdDoctor() {
  console.log(`\n${BOLD}${CYAN}Golem Doctor${NC}\n`);
  const checks = [];

  // Node version
  const nodeVer = process.version;
  const major = parseInt(nodeVer.slice(1));
  checks.push({ name: 'Node.js >= 18', ok: major >= 18, detail: nodeVer });

  // Command checks — cache results to avoid redundant subprocess spawns
  const hasClaude = hasCommand('claude');
  const hasGit = hasCommand('git');
  const hasPython3 = hasCommand('python3');
  const hasJq = hasCommand('jq');
  const hasPnpm = hasCommand('pnpm');
  const hasNpx = hasCommand('npx');
  const hasSemgrep = hasCommand('semgrep');

  checks.push({ name: 'claude CLI', ok: hasClaude, detail: hasClaude ? 'found' : 'not found' });
  checks.push({ name: 'git', ok: hasGit, detail: hasGit ? 'found' : 'not found' });
  checks.push({ name: 'python3', ok: hasPython3, detail: hasPython3 ? 'found' : 'not found (optional)', optional: true });
  checks.push({ name: 'jq', ok: hasJq, detail: hasJq ? 'found' : 'MISSING — security hooks will block all commands' });
  checks.push({ name: 'pnpm or npx', ok: hasPnpm || hasNpx, detail: hasPnpm ? 'pnpm found' : hasNpx ? 'npx found' : 'not found' });
  checks.push({ name: 'semgrep', ok: hasSemgrep, detail: hasSemgrep ? 'found' : 'not found (optional)', optional: true });

  // Golem home
  const homeExists = fs.existsSync(GOLEM_HOME);
  checks.push({ name: 'GOLEM_HOME', ok: homeExists, detail: homeExists ? GOLEM_HOME : 'missing' });

  // Version file
  const versionExists = fs.existsSync(VERSION_FILE);
  checks.push({ name: 'Version stamp', ok: versionExists, detail: versionExists ? getVersion() : 'missing' });

  // Golem binary
  const golemBin = path.join(GOLEM_HOME, 'bin', 'golem');
  checks.push({ name: 'Golem binary', ok: fs.existsSync(golemBin), detail: fs.existsSync(golemBin) ? 'found' : 'missing' });

  // PATH check
  const pathHasGolem = (process.env.PATH || '').includes('.golem/bin');
  checks.push({ name: 'PATH includes golem', ok: pathHasGolem, detail: pathHasGolem ? 'configured' : 'missing — restart terminal or source shell RC' });

  // Claude home files
  const claudeHome = path.join(HOME, '.claude');
  const claudeMd = path.join(claudeHome, 'CLAUDE.md');
  checks.push({ name: '~/.claude/CLAUDE.md', ok: fs.existsSync(claudeMd), detail: fs.existsSync(claudeMd) ? 'found' : 'missing' });

  const settingsJson = path.join(claudeHome, 'settings.json');
  checks.push({ name: '~/.claude/settings.json', ok: fs.existsSync(settingsJson), detail: fs.existsSync(settingsJson) ? 'found' : 'missing' });

  const scannerMd = path.join(claudeHome, 'agents', 'security-scanner.md');
  checks.push({ name: 'Security scanner agent', ok: fs.existsSync(scannerMd), detail: fs.existsSync(scannerMd) ? 'found' : 'missing' });

  // MCP config
  const mcpJson = path.join(HOME, '.mcp.json');
  checks.push({ name: '~/.mcp.json', ok: fs.existsSync(mcpJson), detail: fs.existsSync(mcpJson) ? 'found' : 'missing', optional: true });

  // Hooks
  const hooksDir = path.join(GOLEM_HOME, 'hooks');
  const hooksExist = fs.existsSync(hooksDir) && fs.readdirSync(hooksDir).length > 0;
  checks.push({ name: 'Hooks', ok: hooksExist, detail: hooksExist ? `${fs.readdirSync(hooksDir).length} hook(s)` : 'missing' });

  // Skills
  const skillsDir = path.join(GOLEM_HOME, 'skills');
  const skillsExist = fs.existsSync(skillsDir);
  checks.push({ name: 'Skills', ok: skillsExist, detail: skillsExist ? 'installed' : 'missing' });

  // Templates
  const templatesDir = path.join(GOLEM_HOME, 'templates');
  checks.push({ name: 'Templates', ok: fs.existsSync(templatesDir), detail: fs.existsSync(templatesDir) ? 'installed' : 'missing' });

  // Print results
  let allOk = true;
  for (const c of checks) {
    const icon = c.ok ? `${GREEN}OK${NC}` : (c.optional ? `${YELLOW}--${NC}` : `${RED}FAIL${NC}`);
    console.log(`  ${icon}  ${c.name.padEnd(24)} ${DIM}${c.detail}${NC}`);
    if (!c.ok && !c.optional) allOk = false;
  }

  console.log();
  if (allOk) {
    console.log(`  ${GREEN}All required checks passed.${NC}\n`);
  } else {
    const diag = diagnostics.detectState(GOLEM_HOME);
    console.error(errors.formatError({
      message: 'Some required checks failed',
      context: {
        failedChecks: checks.filter(c => !c.ok && !c.optional).map(c => c.name).join(', '),
      },
      diagnostics: diag,
    }));
    console.log(); // blank line after error
    process.exit(1);
  }
}

function cmdInit(args = []) {
  const cwd = process.cwd();
  const blocked = ['/', '/usr', '/bin', '/sbin', '/etc', '/var', '/opt', '/tmp',
                   '/Library', '/System', HOME];
  if (blocked.includes(cwd)) {
    console.error(errors.formatError({
      message: 'Cannot initialize golem in system directory',
      context: {
        cwd: cwd,
        reason: 'Directory is blocked (system or home directory)',
      },
      suggestion: 'Navigate to a project directory first (cd ~/projects/my-app)',
    }));
    process.exit(1);
  }

  // Parse flags for explicit stack/db overrides
  const validFlags = new Set(['nuxt', 'next', 'php', 'pg', 'postgres', 'oracle', 'mssql', 'ibmi']);
  const rawFlags = args.filter(a => a.startsWith('--')).map(a => a.slice(2).toLowerCase());
  const unknownFlags = rawFlags.filter(f => !validFlags.has(f));
  if (unknownFlags.length) {
    console.log(`${YELLOW}Unknown flags ignored: ${unknownFlags.map(f => '--' + f).join(', ')}${NC}`);
  }
  const flags = new Set(rawFlags.filter(f => validFlags.has(f)));

  console.log(`\n${BOLD}${CYAN}Initializing golem in ${cwd}${NC}\n`);

  // Create .claude and .golem dirs
  for (const dir of ['.claude/commands', '.claude/agents', '.golem/logs', '.golem/plans']) {
    fs.mkdirSync(path.join(cwd, dir), { recursive: true, mode: 0o700 });
    console.log(`  ${GREEN}Created${NC} ${dir}/`);
  }

  // Copy templates
  const templatesDir = path.join(GOLEM_HOME, 'templates');
  if (!fs.existsSync(templatesDir)) {
    const diag = diagnostics.detectState(GOLEM_HOME);
    console.error(errors.formatError({
      message: 'Templates not found',
      context: {
        expected: templatesDir,
        GOLEM_HOME: GOLEM_HOME,
      },
      diagnostics: diag,
    }));
    process.exit(1);
  }

  // Helper: symlink-safe copy for template files
  function safeCopyTemplate(src, dest, label) {
    if (fs.existsSync(dest)) {
      if (fs.lstatSync(dest).isSymbolicLink()) {
        console.log(`  ${YELLOW}Skipped${NC}   ${label} (symlink)`);
        return false;
      }
      console.log(`  ${DIM}Exists${NC}    ${label}`);
      return false;
    }
    fs.copyFileSync(src, dest);
    console.log(`  ${GREEN}Installed${NC} ${label}`);
    return true;
  }

  // Commands
  const commandsSrc = path.join(templatesDir, 'commands');
  if (fs.existsSync(commandsSrc)) {
    for (const file of fs.readdirSync(commandsSrc)) {
      safeCopyTemplate(path.join(commandsSrc, file), path.join(cwd, '.claude', 'commands', file), `.claude/commands/${file}`);
    }
  }

  // Agents
  const agentsSrc = path.join(templatesDir, 'agents');
  if (fs.existsSync(agentsSrc)) {
    for (const file of fs.readdirSync(agentsSrc)) {
      safeCopyTemplate(path.join(agentsSrc, file), path.join(cwd, '.claude', 'agents', file), `.claude/agents/${file}`);
    }
  }

  // settings.json
  const settingsSrc = path.join(templatesDir, 'settings.json');
  safeCopyTemplate(settingsSrc, path.join(cwd, '.claude', 'settings.json'), '.claude/settings.json');

  // settings.local.json
  const settingsLocalSrc = path.join(templatesDir, 'settings.local.json');
  safeCopyTemplate(settingsLocalSrc, path.join(cwd, '.claude', 'settings.local.json'), '.claude/settings.local.json');

  // mcp.json
  const mcpSrc = path.join(templatesDir, 'mcp.json');
  safeCopyTemplate(mcpSrc, path.join(cwd, '.mcp.json'), '.mcp.json');

  // Initialize state
  const stateDest = path.join(cwd, '.golem', 'state.json');
  if (!fs.existsSync(stateDest)) {
    fs.writeFileSync(stateDest, JSON.stringify({
      phase: 'initialized',
      tasks_completed: 0,
      tasks_total: 0,
      created: new Date().toISOString(),
    }, null, 2));
    console.log(`  ${GREEN}Created${NC}   .golem/state.json`);
  }

  // CLAUDE.md
  const claudeMdDest = path.join(cwd, 'CLAUDE.md');
  if (!fs.existsSync(claudeMdDest)) {
    const projectType = detectProjectType(cwd, flags);

    // Detect databases (flags override/extend auto-detection)
    const detectedDBs = detectDatabases();
    if (flags.has('pg') || flags.has('postgres')) detectedDBs.push('postgres');
    if (flags.has('oracle')) detectedDBs.push('oracle');
    if (flags.has('mssql')) detectedDBs.push('mssql');
    if (flags.has('ibmi')) detectedDBs.push('ibmi');
    const uniqueDBs = [...new Set(detectedDBs)];

    // Build skill references
    const skillRefs = [];
    const skillMap = {
      'Nuxt': 'frameworks/nuxt.md', 'Next.js': 'frameworks/next.md', 'PHP': 'frameworks/php.md',
    };
    if (skillMap[projectType]) skillRefs.push(`~/.golem/skills/${skillMap[projectType]}`);
    for (const db of uniqueDBs) skillRefs.push(`~/.golem/skills/databases/${db}.md`);

    let claudeMd = `# ${path.basename(cwd)}

## Project Type
${projectType}

## Conventions
- Follow existing code style
- Write tests for new features
- Use conventional commits

## Environment
- See .env.example for required variables
`;

    if (skillRefs.length > 0) {
      claudeMd += `
## Stack Skills
Read these references before working on this project:
${skillRefs.map(s => `- ${s}`).join('\n')}
`;
    }

    claudeMd += `
## Golem Workflow
Available commands: discuss, spec, plan, build, release, sweep, recon, status
Run \`golem help\` for details.
`;

    fs.writeFileSync(claudeMdDest, claudeMd);
    const detectionSummary = uniqueDBs.length > 0 ? `, DBs: ${uniqueDBs.join(', ')}` : '';
    console.log(`  ${GREEN}Created${NC}   CLAUDE.md (detected: ${projectType}${detectionSummary})`);
    if (skillRefs.length > 0) {
      console.log(`  ${GREEN}Linked${NC}    ${skillRefs.length} skill reference(s)`);
    }
  }

  // .env.example
  const envExDest = path.join(cwd, '.env.example');
  if (!fs.existsSync(envExDest)) {
    fs.writeFileSync(envExDest, '# Add your environment variables here\n');
    console.log(`  ${GREEN}Created${NC}   .env.example`);
  }

  // Ensure .gitignore has .env and .golem/
  updateGitignore(cwd);

  console.log(`\n  ${BOLD}${GREEN}Project initialized.${NC} Run ${CYAN}claude${NC} to start.\n`);
}

function cmdStatus() {
  const stateFile = path.join(process.cwd(), '.golem', 'state.json');
  if (!fs.existsSync(stateFile)) {
    console.log(`${YELLOW}No golem state found. Run 'golem init' first.${NC}`);
    process.exit(1);
  }
  let state;
  try {
    state = JSON.parse(fs.readFileSync(stateFile, 'utf-8'));
  } catch {
    console.error(errors.formatError({
      message: '.golem/state.json is corrupted',
      context: {
        file: stateFile,
        reason: 'Invalid JSON syntax',
      },
      suggestion: 'Run: golem reset',
    }));
    process.exit(1);
  }
  console.log(`\n${BOLD}Golem Status${NC}`);
  console.log(`  Phase:     ${state.phase || 'unknown'}`);
  console.log(`  Tasks:     ${state.tasks_completed || 0}/${state.tasks_total || 0}`);
  console.log(`  Created:   ${state.created || 'unknown'}`);

  // Show git info
  try {
    const branch = execSync('git branch --show-current', { stdio: 'pipe', cwd: process.cwd() }).toString().trim();
    const status = execSync('git status --short', { stdio: 'pipe', cwd: process.cwd() }).toString().trim();
    console.log(`  Branch:    ${branch}`);
    console.log(`  Git:       ${status ? status.split('\n').length + ' changed files' : 'clean'}`);
  } catch { /* not a git repo */ }
  console.log();
}

function cmdReset() {
  const golemDir = path.join(process.cwd(), '.golem');
  if (!fs.existsSync(golemDir)) {
    console.log(`${YELLOW}No .golem directory found.${NC}`);
    return;
  }
  const stateFile = path.join(golemDir, 'state.json');
  if (fs.existsSync(stateFile)) {
    fs.writeFileSync(stateFile, JSON.stringify({
      phase: 'initialized',
      tasks_completed: 0,
      tasks_total: 0,
      created: new Date().toISOString(),
    }, null, 2));
  }
  // Clear logs
  const logsDir = path.join(golemDir, 'logs');
  if (fs.existsSync(logsDir)) {
    fs.rmSync(logsDir, { recursive: true });
    fs.mkdirSync(logsDir, { recursive: true });
  }
  console.log(`${GREEN}Golem state reset.${NC}`);
}

function cmdEject(args = []) {
  const golemDir = path.join(process.cwd(), '.golem');
  if (!fs.existsSync(golemDir)) {
    console.log(`${YELLOW}No .golem directory found.${NC}`);
    return;
  }

  if (!args.includes('--confirm') && !args.includes('-y')) {
    console.log(`${YELLOW}This will permanently delete:${NC}`);
    console.log(`  ${golemDir}/  (all state, logs, plans, specs)`);
    console.log(`\n${BOLD}Run with --confirm to proceed:${NC} golem eject --confirm`);
    return;
  }

  fs.rmSync(golemDir, { recursive: true });
  console.log(`${GREEN}Removed${NC} .golem/`);
  console.log(`${DIM}.claude/ left intact (contains your commands and settings).${NC}`);
  console.log(`${GREEN}Golem ejected. Your code is untouched.${NC}`);
}

function cmdUpdate() {
  const current = getVersion();
  console.log(`${CYAN}Current version: ${current}${NC}`);
  console.log(`${CYAN}Updating golem to latest...${NC}`);
  const runner = hasCommand('pnpm') ? 'pnpm' : 'npx';
  const dlxArgs = runner === 'pnpm' ? ['dlx', 'golem-cc@latest'] : ['-y', 'golem-cc@latest'];
  const result = spawnSync(runner, dlxArgs, {
    stdio: 'inherit',
    cwd: HOME,
  });
  if (result.status === 0) {
    const updated = getVersion();
    if (updated !== current) {
      console.log(`${GREEN}Updated: ${current} → ${updated}${NC}`);
    } else {
      console.log(`${GREEN}Already on latest (${current}).${NC}`);
    }
  }
  process.exit(result.status ?? 1);
}

function cmdUninstall(args = [], { home } = {}) {
  const _home = home || HOME;
  if (!args.includes('--confirm') && !args.includes('-y')) {
    console.log(`\n${BOLD}${YELLOW}Golem Uninstall${NC}\n`);
    console.log(`This will:`);
    console.log(`  1. Restore any .pre-golem backup files in ~/.claude/`);
    console.log(`  2. Remove ~/.golem/ entirely`);
    console.log(`  3. Remove the PATH entry from shell RC files`);
    console.log(`\n${BOLD}Run with --confirm to proceed:${NC} golem uninstall --confirm`);
    return;
  }

  const CLAUDE_HOME = path.join(_home, '.claude');
  const GOLEM_HOME_DIR = path.join(_home, '.golem');

  // 1. Restore .pre-golem backups in ~/.claude/
  if (fs.existsSync(CLAUDE_HOME)) {
    const restoreBackups = (dir) => {
      if (!fs.existsSync(dir)) return;
      for (const file of fs.readdirSync(dir)) {
        const full = path.join(dir, file);
        const stat = fs.lstatSync(full);
        if (stat.isDirectory()) { restoreBackups(full); continue; }
        if (file.endsWith('.pre-golem')) {
          const original = full.replace(/\.pre-golem$/, '');
          fs.renameSync(full, original);
          console.log(`  ${GREEN}Restored${NC} ${original.replace(_home, '~')}`);
        }
      }
    };
    restoreBackups(CLAUDE_HOME);
    // Clean up .new files left by smartCopy
    const cleanNewFiles = (dir) => {
      if (!fs.existsSync(dir)) return;
      for (const file of fs.readdirSync(dir)) {
        const full = path.join(dir, file);
        const stat = fs.lstatSync(full);
        if (stat.isDirectory()) { cleanNewFiles(full); continue; }
        if (file.endsWith('.new')) {
          fs.unlinkSync(full);
          console.log(`  ${DIM}Removed${NC}   ${full.replace(_home, '~')}`);
        }
      }
    };
    cleanNewFiles(CLAUDE_HOME);
  }

  // 2. Remove golem-created files that have no backup (golem was the first to install them)
  const manifestPath = path.join(GOLEM_HOME_DIR, 'installed-files.json');
  if (fs.existsSync(manifestPath)) {
    try {
      const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));
      for (const f of manifest) {
        if (fs.existsSync(f) && !fs.existsSync(f + '.pre-golem')) {
          fs.unlinkSync(f);
          console.log(`  ${GREEN}Removed${NC}   ${f.replace(_home, '~')}`);
        }
      }
    } catch { /* corrupt manifest — skip cleanup */ }
  }

  // 3. Remove ~/.golem/
  if (fs.existsSync(GOLEM_HOME_DIR)) {
    fs.rmSync(GOLEM_HOME_DIR, { recursive: true });
    console.log(`  ${GREEN}Removed${NC}   ~/.golem/`);
  }

  // 4. Remove PATH entry from shell RC files
  for (const rc of ['.zshrc', '.bashrc']) {
    const rcPath = path.join(_home, rc);
    if (!fs.existsSync(rcPath)) continue;
    const content = fs.readFileSync(rcPath, 'utf-8');
    if (content.includes('.golem/bin')) {
      const cleaned = content
        .replace(/\n# Super Golem\nexport PATH="\$PATH:\$HOME\/\.golem\/bin"\n/g, '')
        .replace(/\n# Super Golem\nexport PATH="\$HOME\/\.golem\/bin:\$PATH"\n/g, '');
      if (cleaned !== content) {
        fs.writeFileSync(rcPath, cleaned);
        console.log(`  ${GREEN}Cleaned${NC}   ~/${rc} (removed PATH entry)`);
      }
    }
  }

  console.log(`\n${GREEN}Golem uninstalled.${NC}`);
  console.log(`${DIM}Your projects are untouched. To clean up, delete the .golem/ directory in each project.${NC}`);
}

function cmdLog(args = []) {
  const logsDir = path.join(process.cwd(), '.golem', 'logs');
  if (!fs.existsSync(logsDir)) {
    console.log(`${YELLOW}No logs found. Run 'golem init' first.${NC}`);
    return;
  }
  const files = fs.readdirSync(logsDir).sort().reverse();
  if (files.length === 0) {
    console.log(`${DIM}No log entries yet.${NC}`);
    return;
  }
  // Show N most recent logs (default 1, max 100)
  const count = Math.min(Math.max(1, parseInt(args[0]) || 1), 100);
  const toShow = files.slice(0, count);
  for (const file of toShow) {
    console.log(`${BOLD}${file}${NC}\n`);
    try {
      console.log(fs.readFileSync(path.join(logsDir, file), 'utf-8'));
    } catch { console.log(`${DIM}(file removed)${NC}`); }
    if (toShow.length > 1) console.log(`${DIM}${'─'.repeat(40)}${NC}\n`);
  }
}

function cmdDiff() {
  if (!hasCommand('git')) {
    console.error(errors.formatError({
      message: 'git not found',
      context: {
        PATH: process.env.PATH ? 'configured' : 'empty',
      },
      suggestion: 'Install git: https://git-scm.com/downloads',
    }));
    process.exit(1);
  }
  const check = spawnSync('git', ['rev-parse', '--is-inside-work-tree'], { stdio: 'pipe', cwd: process.cwd() });
  if (check.status !== 0) {
    console.error(errors.formatError({
      message: 'Not a git repository',
      context: {
        cwd: process.cwd(),
      },
      suggestion: 'Run: git init',
    }));
    process.exit(1);
  }
  const result = spawnSync('git', ['diff', '--stat'], { stdio: 'inherit', cwd: process.cwd() });
  process.exit(result.status ?? 1);
}

// ============================================================================
// Exports for testing — functions are available via require() without running dispatch
// ============================================================================

module.exports = { sanitizeArgs, hasCommand, detectDatabases, detectProjectType, updateGitignore, cmdInit, cmdDoctor, cmdStatus, cmdReset, cmdEject, cmdUninstall, cmdLog };

// ============================================================================
// Dispatch — only runs when executed directly
// ============================================================================

if (require.main === module) {

const [,, command, ...args] = process.argv;
const argsStr = sanitizeArgs(args.join(' '));

if (!command || command === '--help' || command === '-h') {
  printHelp();
  process.exit(0);
}

if (command === 'help') {
  if (args[0]) {
    // golem help <command> — show detailed help from command file
    const cmdFile = path.join(process.cwd(), '.claude', 'commands', `golem-${args[0]}.md`);
    if (fs.existsSync(cmdFile)) {
      const content = fs.readFileSync(cmdFile, 'utf-8');
      const descMatch = content.match(/description:\s*(.+)/);
      const toolsMatch = content.match(/allowed-tools:\s*(.+)/);
      console.log(`\n${BOLD}golem ${args[0]}${NC}`);
      if (descMatch) console.log(`  ${descMatch[1]}`);
      if (toolsMatch) console.log(`  ${DIM}Tools: ${toolsMatch[1]}${NC}`);
      console.log(`\n  ${DIM}Full reference: ${cmdFile}${NC}\n`);
    } else {
      // Check if it's a known command
      const allCmds = { ...WORKFLOW_COMMANDS, ...INTELLIGENCE_COMMANDS, ...MAINTENANCE_COMMANDS };
      if (args[0] in allCmds) {
        console.log(`\n${BOLD}golem ${args[0]}${NC}: ${allCmds[args[0]]}\n`);
      } else {
        console.log(`${YELLOW}No help available for '${args[0]}'${NC}`);
      }
    }
  } else {
    printHelp();
  }
  process.exit(0);
}

// Workflow commands → shell out to claude with slash command
if (command in WORKFLOW_COMMANDS) {
  if (command === 'discuss' && !argsStr.trim()) {
    console.error(errors.formatError({
      message: 'Missing required argument for discuss command',
      context: {
        command: 'discuss',
      },
      suggestion: 'Usage: golem discuss "your topic here"',
    }));
    process.exit(1);
  }
  claudeSlashCommand(command, argsStr);
}

// Intelligence commands
switch (command) {
  case 'status': cmdStatus(); break;
  case 'sweep': claudeSlashCommand('sweep', argsStr); break;
  case 'recon': claudeSlashCommand('recon', argsStr); break;
  case 'diff': cmdDiff(); break;
  case 'log': cmdLog(args); break;

  // Maintenance commands
  case 'version': case '--version': case '-v': cmdVersion(); break;
  case 'doctor': cmdDoctor(); break;
  case 'init': cmdInit(args); break;
  case 'reset': cmdReset(); break;
  case 'eject': cmdEject(args); break;
  case 'uninstall': cmdUninstall(args); break;
  case 'update': cmdUpdate(); break;

  default:
    console.error(errors.formatError({
      message: `Unknown command: ${command}`,
      context: {
        command: command,
      },
      suggestion: 'Run: golem help',
    }));
    console.error(''); // blank line before help
    printHelp();
    process.exit(1);
}

} // end if (require.main === module)
